---
// Calendar Booking Component for Shallow Bay Advisors
interface Props {
  title?: string;
  subtitle?: string;
  buttonText?: string;
  propertyId?: string;
  propertyTitle?: string;
}

const {
  title = "Schedule a Consultation",
  subtitle = "Book a call with our commercial real estate experts",
  buttonText = "Book Appointment",
  propertyId,
  propertyTitle
} = Astro.props;

// Time slots will be dynamically loaded from CRM availability API
// This array is kept as fallback only
const fallbackTimeSlots = [
  "9:00 AM", "9:30 AM", "10:00 AM", "10:30 AM", "11:00 AM", "11:30 AM",
  "1:00 PM", "1:30 PM", "2:00 PM", "2:30 PM", "3:00 PM", "3:30 PM", "4:00 PM"
];

// Properties will be loaded dynamically from CRM API
const CRM_BASE_URL = 'https://sbaycrm.netlify.app';
---

<div class="p-0">
  <!-- Header (only show if title exists) -->
  {title && (
    <div class="mb-8 text-center">
      <h3 class="text-2xl font-semibold text-sba-navy mb-3">
        {title}
      </h3>
      {subtitle && (
        <p class="text-gray-600 text-lg">
          {subtitle}
        </p>
      )}
    </div>
  )}

  <!-- Calendar Booking Form -->
  <form id="calendar-booking-form" class="space-y-6">
    <!-- Contact Information -->
    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
      <div>
        <label for="booking-name" class="block text-sm font-medium text-gray-700 mb-2">
          Full Name *
        </label>
        <input
          type="text"
          id="booking-name"
          name="name"
          required
          class="w-full px-3 py-2 rounded-lg border border-gray-300 focus:ring-2 focus:ring-sba-navy/20 focus:border-sba-navy bg-white text-sm transition-all duration-300"
          placeholder="Your name"
        />
      </div>
      <div>
        <label for="booking-email" class="block text-sm font-medium text-gray-700 mb-2">
          Email Address *
        </label>
        <input
          type="email"
          id="booking-email"
          name="email"
          required
          class="w-full px-3 py-2 rounded-lg border border-gray-300 focus:ring-2 focus:ring-sba-navy/20 focus:border-sba-navy bg-white text-sm transition-all duration-300"
          placeholder="your@email.com"
        />
      </div>
      <div>
        <label for="booking-phone" class="block text-sm font-medium text-gray-700 mb-2">
          Phone Number *
        </label>
        <input
          type="tel"
          id="booking-phone"
          name="phone"
          required
          class="w-full px-3 py-2 rounded-lg border border-gray-300 focus:ring-2 focus:ring-sba-navy/20 focus:border-sba-navy bg-white text-sm transition-all duration-300"
          placeholder="(555) 123-4567"
        />
      </div>
      <div>
        <label for="booking-company" class="block text-sm font-medium text-gray-700 mb-2">
          Company
        </label>
        <input
          type="text"
          id="booking-company"
          name="company"
          class="w-full px-3 py-2 rounded-lg border border-gray-300 focus:ring-2 focus:ring-sba-navy/20 focus:border-sba-navy bg-white text-sm transition-all duration-300"
          placeholder="Company name"
        />
      </div>
    </div>

    <!-- Appointment Details Row -->
    <div class="space-y-4">
      <!-- Property Selection (conditionally shown) -->
      {!propertyId ? (
        <div>
          <label for="property-selection" class="block text-sm font-medium text-gray-700 mb-2">
            Property to View *
          </label>
          <select
            id="property-selection"
            name="property_id"
            required
            class="w-full px-3 py-2 rounded-lg border border-gray-300 focus:ring-2 focus:ring-sba-navy/20 focus:border-sba-navy bg-white text-sm transition-all duration-300 appearance-none"
          >
            <option value="">Select a property to tour...</option>
            <!-- Properties will be loaded dynamically via JavaScript -->
          </select>
        </div>
      ) : (
        <div>
          <label class="block text-sm font-medium text-gray-700 mb-2">
            Property to View
          </label>
          <div class="w-full px-3 py-2 rounded-lg border border-gray-200 bg-gray-50 text-sm text-gray-900">
            üìç {propertyTitle}
          </div>
          <input type="hidden" name="property_id" value={propertyId} />
        </div>
      )}

      <!-- Date and Time Row -->
      <div class="grid grid-cols-2 gap-4">
        <!-- Date Selection -->
        <div>
          <label class="block text-sm font-medium text-gray-700 mb-2">
            Preferred Date *
          </label>
          <div id="custom-calendar" class="border border-gray-200 rounded-xl p-6 bg-white shadow-sm">
            <!-- Calendar Header -->
            <div class="flex items-center justify-between mb-6">
              <button type="button" id="prev-month" class="p-2 hover:bg-gray-100 rounded-lg transition-colors">
                <svg class="w-5 h-5 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"/>
                </svg>
              </button>
              <h3 id="calendar-month-year" class="text-xl font-semibold text-gray-900"></h3>
              <button type="button" id="next-month" class="p-2 hover:bg-gray-100 rounded-lg transition-colors">
                <svg class="w-5 h-5 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/>
                </svg>
              </button>
            </div>

            <!-- Day Headers -->
            <div class="grid grid-cols-7 mb-2">
              <div class="text-center text-sm font-medium text-gray-500 py-2">Sun</div>
              <div class="text-center text-sm font-medium text-gray-500 py-2">Mon</div>
              <div class="text-center text-sm font-medium text-gray-500 py-2">Tue</div>
              <div class="text-center text-sm font-medium text-gray-500 py-2">Wed</div>
              <div class="text-center text-sm font-medium text-gray-500 py-2">Thu</div>
              <div class="text-center text-sm font-medium text-gray-500 py-2">Fri</div>
              <div class="text-center text-sm font-medium text-gray-500 py-2">Sat</div>
            </div>

            <!-- Calendar Grid -->
            <div id="calendar-dates" class="grid grid-cols-7 gap-1">
              <!-- Calendar dates will be populated here -->
            </div>

            <!-- Legend -->
            <div class="mt-4 pt-4 border-t border-gray-100">
              <div class="flex items-center justify-center gap-6 text-sm">
                <div class="flex items-center gap-2">
                  <div class="w-3 h-3 bg-green-100 border border-green-300 rounded"></div>
                  <span class="text-gray-600">Available</span>
                </div>
                <div class="flex items-center gap-2">
                  <div class="w-3 h-3 bg-gray-100 border border-gray-300 rounded"></div>
                  <span class="text-gray-600">Unavailable</span>
                </div>
              </div>
            </div>
          </div>
          <input type="hidden" id="appointment-date" name="appointment_date" required />
          <div id="selected-date-display" class="mt-2 text-sm text-gray-600"></div>
        </div>

        <!-- Time Selection -->
        <div>
          <label for="appointment-time" class="block text-sm font-medium text-gray-700 mb-2">
            Preferred Time *
          </label>
          <select
            id="appointment-time"
            name="appointment_time"
            required
            class="w-full px-3 py-2 rounded-lg border border-gray-300 focus:ring-2 focus:ring-sba-navy/20 focus:border-sba-navy bg-white text-sm transition-all duration-300"
          >
            <option value="">Select date first...</option>
            {fallbackTimeSlots.map(time => (
              <option value={time} class="fallback-option" style="display: none;">{time}</option>
            ))}
          </select>
        </div>
      </div>
    </div>

    <!-- Hidden Property Tracking (invisible to user) -->
    {propertyId && (
      <div>
        <input type="hidden" name="property_title" value={propertyTitle} />
        <input type="hidden" name="property_interest" value={`Property Interest - Regarding: ${propertyTitle}`} />
      </div>
    )}

    <!-- Message -->
    <div>
      <label for="booking-message" class="block text-sm font-medium text-gray-700 mb-2">
        Additional Details
      </label>
      <textarea
        id="booking-message"
        name="message"
        rows="3"
        class="w-full px-3 py-2 rounded-lg border border-gray-300 focus:ring-2 focus:ring-sba-navy/20 focus:border-sba-navy bg-white text-sm resize-none transition-all duration-300"
        placeholder="Tell us about your requirements..."
      ></textarea>
    </div>

    <!-- Submit Button -->
    <div class="pt-4">
      <button
        type="submit"
        id="booking-submit-btn"
        class="w-full px-6 py-3 bg-sba-navy text-white rounded-lg font-semibold hover:bg-sba-navy-dark focus:outline-none focus:ring-4 focus:ring-sba-navy/30 transition-all duration-300 disabled:opacity-50"
      >
        <span class="submit-text">{buttonText}</span>
        <span class="loading-text hidden">Booking Appointment...</span>
      </button>
    </div>

    <!-- Success Message -->
  </form>
</div>

<!-- Success Modal -->
<div id="booking-success-modal" class="hidden fixed inset-0 z-50 flex items-center justify-center p-4">
  <!-- Overlay -->
  <div class="absolute inset-0 bg-black bg-opacity-50"></div>

  <!-- Modal Content -->
  <div class="relative bg-white dark:bg-gray-800 rounded-2xl shadow-2xl max-w-md w-full p-8 text-center">
    <!-- Success Icon -->
    <div class="w-16 h-16 bg-green-100 dark:bg-green-900/40 rounded-full flex items-center justify-center mx-auto mb-6">
      <svg class="w-8 h-8 text-green-600 dark:text-green-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"/>
      </svg>
    </div>

    <!-- Success Message -->
    <h2 class="text-2xl font-semibold text-gray-900 dark:text-white mb-3">
      Tour Booked Successfully!
    </h2>
    <p class="text-gray-600 dark:text-gray-300 mb-8">
      Check your email for tour details and confirmation link.
    </p>

    <!-- Browse More Button -->
    <a
      href="/find"
      class="inline-block w-full bg-blue-600 hover:bg-blue-700 text-white font-medium py-3 px-6 rounded-lg transition-colors duration-200"
    >
      Browse More Properties
    </a>
  </div>
</div>

<script is:inline>
  document.addEventListener('DOMContentLoaded', function() {
    const CRM_API_BASE = '/api'; // Use Netlify Edge Functions
    const CRM_BASE_URL = 'https://sbaycrm.netlify.app';
    let availableDates = new Set();
    let currentSelectedDate = null;
    let currentMonth = new Date().getMonth();
    let currentYear = new Date().getFullYear();
    let currentCalendarDate = new Date(currentYear, currentMonth, 1);

    // Cache to avoid repeated API calls
    let calendarCache = new Map(); // propertyId -> hasCalendar boolean
    let availabilityCache = new Map(); // propertyId-date -> hasAvailability boolean
    let propertiesCache = null; // Store loaded properties

    // Calendar elements
    const dateInput = document.getElementById('appointment-date');
    const timeSelect = document.getElementById('appointment-time');
    const propertySelect = document.getElementById('property-selection');
    const hiddenPropertyId = document.querySelector('input[name="property_id"]');
    const calendarDates = document.getElementById('calendar-dates');
    const calendarMonthYear = document.getElementById('calendar-month-year');
    const prevMonthBtn = document.getElementById('prev-month');
    const nextMonthBtn = document.getElementById('next-month');
    const selectedDateDisplay = document.getElementById('selected-date-display');

    // Get current property ID for availability checks
    function getCurrentPropertyId() {
      if (hiddenPropertyId && hiddenPropertyId.value) {
        return hiddenPropertyId.value;
      }
      if (propertySelect && propertySelect.value) {
        return propertySelect.value;
      }
      return null;
    }

    // Load available time slots for a specific date
    async function loadTimeSlots(propertyId, selectedDate) {
      if (!propertyId || !selectedDate) {
        timeSelect.innerHTML = '<option value="">Select property and date first...</option>';
        return;
      }

      timeSelect.innerHTML = '<option value="">Loading available times...</option>';
      timeSelect.disabled = true;

      try {
        const response = await fetch(`${CRM_BASE_URL}/api/public/appointments/availability?propertyId=${propertyId}&date=${selectedDate}`);

        timeSelect.innerHTML = '<option value="">Select time...</option>';

        if (!response.ok) {
          const errorText = await response.text();
          console.error('Time slots API error:', response.status, errorText);

          // If no calendar configured, provide default business hours
          if (response.status === 404 || errorText.includes('Property not found or no calendar configured')) {
            console.log('No calendar configured, providing default business hours');
            const businessHours = [
              "9:00 AM", "9:30 AM", "10:00 AM", "10:30 AM", "11:00 AM", "11:30 AM",
              "1:00 PM", "1:30 PM", "2:00 PM", "2:30 PM", "3:00 PM", "3:30 PM", "4:00 PM"
            ];

            businessHours.forEach(time => {
              const option = document.createElement('option');
              option.value = time;
              option.textContent = time;
              timeSelect.appendChild(option);
            });
            timeSelect.disabled = false;
            return;
          }

          throw new Error(`HTTP ${response.status}`);
        }

        const data = await response.json();

        if (data.success && data.available_slots && data.available_slots.length > 0) {
          data.available_slots.forEach(slot => {
            const option = document.createElement('option');
            option.value = slot.display_time;
            option.textContent = slot.display_time;
            timeSelect.appendChild(option);
          });
          timeSelect.disabled = false;
        } else {
          timeSelect.innerHTML = '<option value="">No times available for this date</option>';
        }
      } catch (error) {
        console.error('Error loading time slots:', error);
        // Fallback to default business hours
        timeSelect.innerHTML = '<option value="">Select time...</option>';
        const businessHours = [
          "9:00 AM", "9:30 AM", "10:00 AM", "10:30 AM", "11:00 AM", "11:30 AM",
          "1:00 PM", "1:30 PM", "2:00 PM", "2:30 PM", "3:00 PM", "3:30 PM", "4:00 PM"
        ];

        businessHours.forEach(time => {
          const option = document.createElement('option');
          option.value = time;
          option.textContent = time;
          timeSelect.appendChild(option);
        });
        timeSelect.disabled = false;
      }
    }

    // Check if a date has any availability with caching
    async function checkDateAvailability(propertyId, date) {
      if (!propertyId) {
        return false;
      }

      // Check cache first
      const cacheKey = `${propertyId}-${date}`;
      if (availabilityCache.has(cacheKey)) {
        return availabilityCache.get(cacheKey);
      }

      try {
        const url = `${CRM_BASE_URL}/api/public/appointments/availability?propertyId=${propertyId}&date=${date}`;

        const response = await fetch(url);

        if (!response.ok) {
          const errorText = await response.text();

          // If no calendar is configured, check if it's a business day
          if (response.status === 404 || errorText.includes('Property not found or no calendar configured')) {
            const checkDate = new Date(date);
            const dayOfWeek = checkDate.getDay();
            const isBusinessDay = dayOfWeek >= 1 && dayOfWeek <= 5;

            // Cache the result
            availabilityCache.set(cacheKey, isBusinessDay);
            return isBusinessDay;
          }

          // Cache negative result
          availabilityCache.set(cacheKey, false);
          return false;
        }

        const data = await response.json();
        const hasSlots = data.success && data.available_slots && data.available_slots.length > 0;

        // Cache the result
        availabilityCache.set(cacheKey, hasSlots);
        return hasSlots;
      } catch (error) {
        console.error(`Error checking availability for ${date}:`, error);

        // Fallback: business days, cache it
        const checkDate = new Date(date);
        const dayOfWeek = checkDate.getDay();
        const isBusinessDay = dayOfWeek >= 1 && dayOfWeek <= 5;

        availabilityCache.set(cacheKey, isBusinessDay);
        return isBusinessDay;
      }
    }

    // Pre-load availability - simplified for performance
    async function loadAvailableDates(propertyId) {
      if (!propertyId) {
        renderCalendar();
        return;
      }

      // Show loading state
      calendarDates.innerHTML = '<div class="col-span-7 text-center py-4 text-gray-500">Loading...</div>';

      availableDates.clear();

      // First check if this property has a calendar configured at all
      const hasCalendar = await checkPropertyHasCalendar(propertyId);

      if (!hasCalendar) {
        console.log(`No calendar configured for ${propertyId}, using business days fallback`);
        // Use business days as fallback (much faster)
        loadBusinessDaysForMonth(currentYear, currentMonth);
      } else {
        console.log(`Calendar found for ${propertyId}, loading specific availability`);
        // Load specific availability from CRM
        await loadMonthAvailability(propertyId, currentYear, currentMonth);
      }


      // Re-render the calendar
      renderCalendar();
    }

    // Check if property has calendar configuration (cached)
    async function checkPropertyHasCalendar(propertyId) {
      // Check cache first
      if (calendarCache.has(propertyId)) {
        return calendarCache.get(propertyId);
      }

      try {
        // Test with one date to see if calendar exists
        const testDate = new Date();
        testDate.setDate(testDate.getDate() + 1); // Tomorrow
        const dateStr = testDate.toISOString().split('T')[0];

        const response = await fetch(`${CRM_BASE_URL}/api/public/appointments/availability?propertyId=${propertyId}&date=${dateStr}`);

        const hasCalendar = response.ok && response.status !== 404;

        // Cache the result
        calendarCache.set(propertyId, hasCalendar);

        return hasCalendar;
      } catch (error) {
        console.error('Error checking calendar existence:', error);
        calendarCache.set(propertyId, false);
        return false;
      }
    }

    // Load business days for a month (fallback when no calendar)
    function loadBusinessDaysForMonth(year, month) {
      const daysInMonth = new Date(year, month + 1, 0).getDate();
      const today = new Date();
      today.setHours(0, 0, 0, 0);

      for (let day = 1; day <= daysInMonth; day++) {
        const checkDate = new Date(year, month, day);

        // Skip past dates
        if (checkDate < today) continue;

        // No fallback - system requires proper CRM calendar configuration
        // All availability must come from database via API calls
      }
    }

    // Load availability for specific month (when calendar exists)
    async function loadMonthAvailability(propertyId, year, month) {
      const daysInMonth = new Date(year, month + 1, 0).getDate();
      const today = new Date();
      today.setHours(0, 0, 0, 0);

      console.log(`Loading month availability for ${propertyId}, ${year}-${month+1}`);

      // Batch check availability - limit concurrent requests for better performance
      const batchSize = 7; // Check one week at a time
      for (let day = 1; day <= daysInMonth; day += batchSize) {
        const batch = [];

        for (let i = 0; i < batchSize && (day + i) <= daysInMonth; i++) {
          const checkDate = new Date(year, month, day + i);

          // Skip past dates
          if (checkDate < today) continue;

          // Fix timezone offset
          const dateYear = checkDate.getFullYear();
          const dateMonth = String(checkDate.getMonth() + 1).padStart(2, '0');
          const dateDay = String(checkDate.getDate()).padStart(2, '0');
          const dateStr = `${dateYear}-${dateMonth}-${dateDay}`;

          // Check availability for this specific date
          batch.push(
            fetch(`${CRM_BASE_URL}/api/public/appointments/availability?propertyId=${propertyId}&date=${dateStr}`)
              .then(response => {
                if (response.ok) {
                  return response.json().then(data => {
                    if (data.success && data.available_slots && data.available_slots.length > 0) {
                      availableDates.add(dateStr);
                    }
                  });
                }
              })
              .catch(error => {
                console.error(`Error checking availability for ${dateStr}:`, error);
              })
          );
        }

        // Wait for this batch to complete before starting next batch
        await Promise.all(batch);
      }

      console.log(`Found ${availableDates.size} available dates for the month`);
    }

    // Render the custom calendar with proper alignment
    function renderCalendar() {
      const firstDay = new Date(currentYear, currentMonth, 1);
      const lastDay = new Date(currentYear, currentMonth + 1, 0);
      const daysInMonth = lastDay.getDate();
      const startingDayOfWeek = firstDay.getDay(); // 0 = Sunday, 1 = Monday, etc.

      // Update month/year header
      const months = ['January', 'February', 'March', 'April', 'May', 'June',
                     'July', 'August', 'September', 'October', 'November', 'December'];
      calendarMonthYear.textContent = `${months[currentMonth]} ${currentYear}`;

      // Clear previous dates
      calendarDates.innerHTML = '';

      const today = new Date();
      today.setHours(0, 0, 0, 0);

      // Add empty cells for days before the first day of the month
      for (let i = 0; i < startingDayOfWeek; i++) {
        const emptyCell = document.createElement('div');
        emptyCell.className = 'h-12 w-full'; // Maintain grid structure
        calendarDates.appendChild(emptyCell);
      }

      // Add days of the month
      for (let day = 1; day <= daysInMonth; day++) {
        const dateCell = document.createElement('div');
        const currentDate = new Date(currentYear, currentMonth, day);
        // Fix timezone offset: format date as YYYY-MM-DD in local time
        const year = currentDate.getFullYear();
        const month = String(currentDate.getMonth() + 1).padStart(2, '0');
        const dayStr = String(currentDate.getDate()).padStart(2, '0');
        const dateStr = `${year}-${month}-${dayStr}`;
        const isPast = currentDate < today;
        const isAvailable = availableDates.has(dateStr);
        const isSelected = currentSelectedDate === dateStr;

        dateCell.textContent = day;
        dateCell.className = 'h-12 w-full flex items-center justify-center text-sm font-medium rounded-lg transition-all duration-200 ';

        if (isPast) {
          // Past dates - disabled
          dateCell.className += 'text-gray-300 cursor-not-allowed';
        } else if (isAvailable) {
          // Available dates - professional green styling
          dateCell.className += 'bg-green-50 text-green-700 border-2 border-green-200 hover:bg-green-100 hover:border-green-300 cursor-pointer hover:scale-105';
          if (isSelected) {
            dateCell.className += ' bg-green-200 border-green-400 ring-2 ring-green-500 ring-opacity-50';
          }
          dateCell.addEventListener('click', () => selectDate(dateStr));
        } else {
          // Unavailable dates - subtle gray styling
          dateCell.className += 'bg-gray-50 text-gray-400 border border-gray-200 cursor-not-allowed';
        }

        calendarDates.appendChild(dateCell);
      }

      // Add empty cells to complete the last row if needed
      const totalCells = Math.ceil((startingDayOfWeek + daysInMonth) / 7) * 7;
      const cellsAdded = startingDayOfWeek + daysInMonth;
      for (let i = cellsAdded; i < totalCells; i++) {
        const emptyCell = document.createElement('div');
        emptyCell.className = 'h-12 w-full';
        calendarDates.appendChild(emptyCell);
      }
    }

    // Select a date
    function selectDate(dateStr) {
      currentSelectedDate = dateStr;
      dateInput.value = dateStr;

      // Update display - parse date correctly to avoid timezone offset
      const [year, month, day] = dateStr.split('-').map(Number);
      const displayDate = new Date(year, month - 1, day);
      selectedDateDisplay.textContent = `Selected: ${displayDate.toLocaleDateString('en-US', {
        weekday: 'long',
        year: 'numeric',
        month: 'long',
        day: 'numeric'
      })}`;

      // Re-render calendar to show selection
      renderCalendar();

      // Load time slots for selected date
      const propertyId = getCurrentPropertyId();
      loadTimeSlots(propertyId, dateStr);
    }

    // Prevent multiple navigation clicks
    let isNavigating = false;

    // Calendar navigation
    prevMonthBtn.addEventListener('click', async function() {
      if (isNavigating) return;
      isNavigating = true;

      this.disabled = true;
      nextMonthBtn.disabled = true;

      if (currentMonth === 0) {
        currentMonth = 11;
        currentYear--;
      } else {
        currentMonth--;
      }
      currentCalendarDate = new Date(currentYear, currentMonth, 1);

      // Clear previous selection when changing months
      currentSelectedDate = null;
      selectedDateDisplay.textContent = '';

      const propertyId = getCurrentPropertyId();
      if (propertyId) {
        await loadAvailableDates(propertyId);
      } else {
        renderCalendar();
      }

      this.disabled = false;
      nextMonthBtn.disabled = false;
      isNavigating = false;
    });

    nextMonthBtn.addEventListener('click', async function() {
      if (isNavigating) return;
      isNavigating = true;

      this.disabled = true;
      prevMonthBtn.disabled = true;

      if (currentMonth === 11) {
        currentMonth = 0;
        currentYear++;
      } else {
        currentMonth++;
      }
      currentCalendarDate = new Date(currentYear, currentMonth, 1);

      // Clear previous selection when changing months
      currentSelectedDate = null;
      selectedDateDisplay.textContent = '';

      const propertyId = getCurrentPropertyId();
      if (propertyId) {
        await loadAvailableDates(propertyId);
      } else {
        renderCalendar();
      }

      this.disabled = false;
      prevMonthBtn.disabled = false;
      isNavigating = false;
    });

    // Handle property selection change
    if (propertySelect) {
      propertySelect.addEventListener('change', async function() {
        const propertyId = this.value;
        if (propertyId) {
          timeSelect.innerHTML = '<option value="">Loading availability...</option>';
          // Reset selection
          currentSelectedDate = null;
          selectedDateDisplay.textContent = '';
          await loadAvailableDates(propertyId);
        } else {
          timeSelect.innerHTML = '<option value="">Select property first...</option>';
          availableDates.clear();
          currentSelectedDate = null;
          selectedDateDisplay.textContent = '';
          renderCalendar();
        }
      });
    }

    // Initialize calendar and load availability
    async function initializeCalendar() {
      // Render initial empty calendar
      renderCalendar();

      // Load availability if property is already selected
      const propertyId = getCurrentPropertyId();
      if (propertyId) {
        await loadAvailableDates(propertyId);
      }
    }

    // Initialize for property-specific booking pages
    if (hiddenPropertyId && hiddenPropertyId.value) {
      initializeCalendar();
    } else {
      // For general booking pages, just render the empty calendar
      renderCalendar();
    }

    // Handle form submission
    const form = document.getElementById('calendar-booking-form');
    if (form) {
      form.addEventListener('submit', async function(e) {
        e.preventDefault();

        const submitBtn = document.getElementById('booking-submit-btn');
        const submitText = submitBtn.querySelector('.submit-text');
        const loadingText = submitBtn.querySelector('.loading-text');
        const successModal = document.getElementById('booking-success-modal');

        // Show loading state
        submitBtn.disabled = true;
        submitText.classList.add('hidden');
        loadingText.classList.remove('hidden');

        try {
          // Validate time slot selection
          if (!timeSelect.value || timeSelect.value === '' || timeSelect.innerHTML.includes('No times available')) {
            alert('Please select an available date and time slot for your appointment.');
            submitBtn.disabled = false;
            submitText.classList.remove('hidden');
            loadingText.classList.add('hidden');
            return;
          }

          // Collect form data
          const formData = new FormData(form);
          const data = Object.fromEntries(formData.entries());

          // Map data for CRM API
          const selectedProperty = document.getElementById('property-selection');
          const propertyId = getCurrentPropertyId();

          if (selectedProperty && selectedProperty.value) {
            const propertyTitle = selectedProperty.options[selectedProperty.selectedIndex].text;
            data.property_interest = propertyTitle;
            data.propertyId = propertyId;
          } else if (data.property_title) {
            // Property already selected (from property detail page)
            data.property_interest = `Property Interest - Regarding: ${data.property_title}`;
            data.propertyId = propertyId;
          }

          // Map date and time for appointment booking
          data.appointmentDate = currentSelectedDate;
          data.appointmentTime = timeSelect.value;

          // Split name into first_name and last_name
          if (data.name) {
            const nameParts = data.name.trim().split(' ');
            data.first_name = nameParts[0] || '';
            data.last_name = nameParts.slice(1).join(' ') || '';
          }

          // Set appointment booking flags
          data.source = 'website';
          data.appointment_type = 'consultation';
          data.status = 'tour-scheduled';

          // Remove conflicting property_id field (keep only propertyId)
          delete data.property_id;

          // Debug: Log what we're actually sending
          console.log('About to send this data:', JSON.stringify(data, null, 2));

          // Submit to CRM leads API
          const response = await fetch(`${CRM_BASE_URL}/api/public/leads`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify(data)
          });

          if (response.ok) {
            // Show success modal
            successModal.classList.remove('hidden');
          } else {
            throw new Error('Booking failed');
          }
        } catch (error) {
          console.error('Error booking appointment:', error);
          alert('There was an error booking your appointment. Please try again or call us directly at (323) 810-7241.');

          // Reset button state
          submitBtn.disabled = false;
          submitText.classList.remove('hidden');
          loadingText.classList.add('hidden');
        }
      });
    }

    // Load properties dynamically on page load
    async function loadPropertiesDropdown() {
      if (!propertySelect) return;

      try {
        const response = await fetch(`${CRM_BASE_URL}/api/public/properties`);
        if (!response.ok) return;

        const data = await response.json();
        if (!data.success || !data.properties) return;

        // Group by county
        const byCounty = {};
        data.properties.forEach(p => {
          let county = 'Other';
          if (p.location?.includes('Miami')) county = 'Miami-Dade';
          else if (p.location?.includes('Broward')) county = 'Broward';
          else if (p.location?.includes('Palm Beach')) county = 'Palm Beach';

          if (!byCounty[county]) byCounty[county] = [];
          byCounty[county].push(p);
        });

        // Clear and repopulate
        while (propertySelect.children.length > 1) {
          propertySelect.removeChild(propertySelect.lastChild);
        }

        Object.entries(byCounty).forEach(([county, properties]) => {
          const optgroup = document.createElement('optgroup');
          optgroup.label = `${county} County`;

          properties.forEach(p => {
            const option = document.createElement('option');
            option.value = p.id;
            option.textContent = `${p.title}${p.sqft ? ` (${p.sqft.toLocaleString()} SF)` : ''}`;
            optgroup.appendChild(option);
          });

          propertySelect.appendChild(optgroup);
        });
      } catch (error) {
        console.log('Could not load properties:', error);
      }
    }

    // Initialize property dropdown
    loadPropertiesDropdown();
  });
</script>

<style>
  /* Select dropdown styling */
  select {
    appearance: none;
    background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='m6 8 4 4 4-4'/%3e%3c/svg%3e");
    background-position: right 12px center;
    background-repeat: no-repeat;
    background-size: 16px;
  }

  select:focus {
    outline: none;
  }

  /* Professional calendar styling */
  #custom-calendar {
    font-family: inherit;
    box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
    background: linear-gradient(135deg, #ffffff 0%, #f9fafb 100%);
  }

  #calendar-dates {
    gap: 2px;
    padding: 4px;
  }

  #calendar-dates > div {
    min-height: 48px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: 600;
    position: relative;
    border-radius: 8px;
    transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
  }

  /* Available date styling */
  #calendar-dates > div.bg-green-50 {
    background: linear-gradient(135deg, #dcfce7 0%, #bbf7d0 100%);
    box-shadow: 0 2px 4px rgba(34, 197, 94, 0.1);
    border: 1px solid #86efac;
  }

  #calendar-dates > div.bg-green-50:hover {
    background: linear-gradient(135deg, #bbf7d0 0%, #86efac 100%);
    box-shadow: 0 4px 12px rgba(34, 197, 94, 0.2);
    transform: translateY(-1px) scale(1.02);
  }

  /* Selected date styling */
  #calendar-dates > div.bg-green-200 {
    background: linear-gradient(135deg, #16a34a 0%, #15803d 100%);
    color: white;
    box-shadow: 0 4px 16px rgba(34, 197, 94, 0.4);
    transform: translateY(-1px);
  }

  /* Unavailable date styling */
  #calendar-dates > div.bg-gray-50 {
    background: linear-gradient(135deg, #f9fafb 0%, #f3f4f6 100%);
    border: 1px solid #e5e7eb;
  }

  /* Past date styling */
  #calendar-dates > div.text-gray-300 {
    background: linear-gradient(135deg, #fafafa 0%, #f5f5f5 100%);
    opacity: 0.6;
  }

  /* Calendar header styling */
  #calendar-month-year {
    font-weight: 700;
    background: linear-gradient(135deg, #1e293b 0%, #334155 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
  }

  /* Navigation button styling */
  #prev-month, #next-month {
    background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
    border: 1px solid #e2e8f0;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
  }

  #prev-month:hover, #next-month:hover {
    background: linear-gradient(135deg, #e2e8f0 0%, #cbd5e1 100%);
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
  }

  /* Day headers styling */
  .grid.grid-cols-7.mb-2 > div {
    font-weight: 700;
    color: #475569;
    background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
    border-radius: 6px;
    margin: 0 1px;
    border: 1px solid #e2e8f0;
  }

  /* Legend styling */
  .border-t.border-gray-100 {
    border-color: #e2e8f0;
    background: linear-gradient(135deg, #f8fafc 0%, #ffffff 100%);
    border-radius: 0 0 12px 12px;
    margin: 0 -6px -6px -6px;
    padding: 16px 24px;
  }

  /* Animation for date selection */
  #calendar-dates > div.ring-2 {
    animation: pulse-green 0.4s ease-in-out;
  }

  @keyframes pulse-green {
    0% { transform: translateY(-1px) scale(1); }
    50% { transform: translateY(-2px) scale(1.05); box-shadow: 0 8px 25px rgba(34, 197, 94, 0.3); }
    100% { transform: translateY(-1px) scale(1); }
  }

  /* Smooth transitions for calendar navigation */
  #calendar-dates {
    animation: fadeIn 0.3s ease-in-out;
  }

  @keyframes fadeIn {
    from { opacity: 0; transform: translateY(10px); }
    to { opacity: 1; transform: translateY(0); }
  }
</style>